<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>AnyCall Customer Test (App Simulation)</title>
    <style>
        body { font-family: sans-serif; padding: 20px; max-width: 900px; margin: 0 auto; }
        .section { border: 1px solid #ddd; padding: 15px; margin-bottom: 15px; border-radius: 5px; }
        h3 { margin-top: 0; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input, select, button { margin-bottom: 10px; width: 100%; padding: 8px; box-sizing: border-box; }
        button { cursor: pointer; background-color: #007bff; color: white; border: none; font-weight: bold; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; }
        button.danger { background-color: #dc3545; }
        button.danger:hover { background-color: #a71d2a; }
        #logs { background: #f0f0f0; height: 400px; overflow-y: scroll; padding: 10px; border: 1px solid #ccc; font-family: monospace; font-size: 12px; }
        .log-sent { color: blue; }
        .log-recv { color: green; }
        .log-err { color: red; font-weight: bold; }
        .log-info { color: #555; }
        .binary-preview { font-size: 11px; color: #666; margin-left: 10px; }
    </style>
</head>
<body>
<h2>ğŸ“± AnyCall Customer Test (anycall.store)</h2>

<div class="section">
    <h3>1. ì¸ì¦ & ì„œë²„ ì„¤ì •</h3>
    <label>Target Domain:</label>
    <input type="text" id="serverDomain" value="anycall.store">
    <label>User ID:</label>
    <input type="text" id="userId" value="1">
    <label>JWT Token (Bearer ì œì™¸):</label>
    <input type="text" id="jwtToken" placeholder="í† í° ì…ë ¥">
</div>

<div class="section">
    <h3>2. í†µí™” ì¤€ë¹„</h3>
    <button onclick="loadVoiceProfiles()">ëª©ì†Œë¦¬ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° (GET)</button>
    <select id="voiceProfileSelect"><option value="">ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ì„¸ìš”</option></select>
</div>

<div class="section">
    <h3>3. í†µí™” ì œì–´</h3>
    <div style="display: flex; gap: 10px;">
        <button id="btnStartCall" onclick="startCall()">ğŸ“ í†µí™” ì‹œì‘ (Start)</button>
        <button id="btnHangup" class="danger" onclick="hangupCall()" disabled>âŒ í†µí™” ì¢…ë£Œ (Hangup)</button>
    </div>
    <p>Status: <span id="status" style="font-weight:bold;">ëŒ€ê¸° ì¤‘</span></p>
</div>

<div class="section">
    <h3>4. ì˜¤ë””ì˜¤ ì‹œë®¬ë ˆì´ì…˜</h3>
    <button id="btnMic" onclick="toggleMic()" disabled>ğŸ™ï¸ ë§ˆì´í¬ ì¼œê¸° (Dummy Data ì „ì†¡)</button>
    <div id="audioStatus">ë§ˆì´í¬ êº¼ì§</div>
</div>

<div class="section">
    <h3>Logs (Binary Detail)</h3>
    <div id="logs"></div>
</div>

<script>
    let websocket = null;
    let currentSessionId = null;
    let isMicOn = false;
    let micInterval = null;

    const logDiv = document.getElementById('logs');
    const statusSpan = document.getElementById('status');

    function getBaseUrl() {
        return `https://${document.getElementById('serverDomain').value}`;
    }

    function getWsUrl() {
        return `wss://${document.getElementById('serverDomain').value}`;
    }

    function log(msg, type = 'log-info') {
        const p = document.createElement('div');
        p.innerHTML = `[${new Date().toLocaleTimeString()}] <span class="${type}">${msg}</span>`;
        logDiv.prepend(p);
    }

    // ì´ì§„ ë°ì´í„° ìƒì„¸ ë¡œê¹… í•¨ìˆ˜
    function logBinary(data, direction) {
        let byteLength = 0;
        let preview = "";
        let view = null;

        if (data instanceof ArrayBuffer) {
            byteLength = data.byteLength;
            view = new Uint8Array(data);
        } else if (data instanceof Blob) {
            byteLength = data.size;
            // Blobì€ ë¹„ë™ê¸°ë¡œ ì½ì–´ì•¼ í•˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ì‚¬ì´ì¦ˆë§Œ í‘œì‹œí•˜ê³  ë³„ë„ ì²˜ë¦¬ í•„ìš”í•  ìˆ˜ ìˆìŒ
            // í¸ì˜ìƒ ArrayBuffer ë³€í™˜ í›„ ë¡œê¹… ê¶Œì¥
        } else if (data instanceof Uint8Array) {
            byteLength = data.byteLength;
            view = data;
        }

        // ì• 16ë°”ì´íŠ¸ë§Œ Hexë¡œ ë³€í™˜í•˜ì—¬ ë¯¸ë¦¬ë³´ê¸°
        if (view) {
            const subarray = view.subarray(0, Math.min(view.length, 16));
            preview = Array.from(subarray).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' ');
            if (view.length > 16) preview += " ...";
        }

        const arrow = direction === 'SENT' ? 'â¬†ï¸' : 'â¬‡ï¸';
        const colorClass = direction === 'SENT' ? 'log-sent' : 'log-recv';

        log(`${arrow} [Binary] Size: ${byteLength} bytes <br><span class="binary-preview">Hex: ${preview}</span>`, colorClass);

        // ì „ì²´ ë°ì´í„°ëŠ” ê°œë°œì ë„êµ¬ ì½˜ì†”ì—ì„œ í™•ì¸ ê°€ëŠ¥í•˜ë„ë¡ ì¶œë ¥
        console.log(`[${direction}] Full Binary Data:`, data);
    }

    async function loadVoiceProfiles() {
        const userId = document.getElementById('userId').value;
        try {
            const response = await fetch(`${getBaseUrl()}/api/voice-profiles/user/${userId}`);
            if (!response.ok) throw new Error('Load Failed');
            const profiles = await response.json();

            const select = document.getElementById('voiceProfileSelect');
            select.innerHTML = '';
            profiles.forEach(p => {
                const opt = document.createElement('option');
                opt.value = p.id;
                opt.textContent = `${p.profileName} (ID: ${p.id})`;
                select.appendChild(opt);
            });
            log(`ëª©ë¡ ë¡œë“œ ì™„ë£Œ: ${profiles.length}ê°œ`);
        } catch (e) {
            log(`ì—ëŸ¬: ${e.message}`, 'log-err');
        }
    }

    async function startCall() {
        const token = document.getElementById('jwtToken').value;
        const profileId = document.getElementById('voiceProfileSelect').value;
        if (!profileId) return alert("í”„ë¡œí•„ ì„ íƒ í•„ìš”");

        try {
            log("í†µí™” ì‹œì‘ ìš”ì²­ (API)...");
            const response = await fetch(`${getBaseUrl()}/api/calls/start`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify({ voiceProfileId: Number(profileId) })
            });

            if (!response.ok) throw new Error(`API Error: ${response.status}`);
            const data = await response.json();
            currentSessionId = data.callSessionId;

            connectWebSocket(currentSessionId);
        } catch (e) {
            log(`ì‹œì‘ ì‹¤íŒ¨: ${e.message}`, 'log-err');
        }
    }

    function connectWebSocket(sessionId) {
        const wsUrl = `${getWsUrl()}/ws-client?callSessionId=${sessionId}`;
        log(`WS ì—°ê²° ì‹œë„: ${wsUrl}`);

        websocket = new WebSocket(wsUrl);
        websocket.binaryType = 'arraybuffer'; // ì´ì§„ ë°ì´í„° íƒ€ì… ì„¤ì •

        websocket.onopen = () => {
            log("âœ… WebSocket Connected", 'log-recv');
            statusSpan.textContent = "ì—°ê²°ë¨";
            statusSpan.style.color = "green";
            document.getElementById('btnStartCall').disabled = true;
            document.getElementById('btnHangup').disabled = false;
            document.getElementById('btnMic').disabled = false;
        };

        websocket.onmessage = (event) => {
            if (event.data instanceof ArrayBuffer) {
                logBinary(event.data, 'RECV');
            } else {
                log(`[Msg] ${event.data}`, 'log-recv');
            }
        };

        websocket.onclose = (e) => {
            log(`âŒ WebSocket Closed (Code: ${e.code})`, 'log-err');
            resetUI();
        };
    }

    async function hangupCall() {
        if (!currentSessionId) return;
        const token = document.getElementById('jwtToken').value;
        try {
            await fetch(`${getBaseUrl()}/api/calls/${currentSessionId}/hangup`, {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${token}` }
            });
            log("í†µí™” ì¢…ë£Œ ìš”ì²­ ì „ì†¡");
        } catch(e) {
            log("ì¢…ë£Œ ìš”ì²­ ì‹¤íŒ¨", 'log-err');
        }
        if (websocket) websocket.close();
    }

    function resetUI() {
        statusSpan.textContent = "ì¢…ë£Œë¨";
        statusSpan.style.color = "black";
        document.getElementById('btnStartCall').disabled = false;
        document.getElementById('btnHangup').disabled = true;
        document.getElementById('btnMic').disabled = true;
        stopMic();
    }

    function toggleMic() {
        if (isMicOn) stopMic();
        else startMic();
    }

    function startMic() {
        isMicOn = true;
        document.getElementById('btnMic').textContent = "â¹ï¸ ë§ˆì´í¬ ë„ê¸°";
        document.getElementById('audioStatus').textContent = "ì „ì†¡ ì¤‘... (1ì´ˆ ê°„ê²©)";

        // ë”ë¯¸ ì˜¤ë””ì˜¤ ë°ì´í„° ìƒì„± (1024 ë°”ì´íŠ¸)
        // ì‹¤ì œë¡œëŠ” ë§ˆì´í¬ ìŠ¤íŠ¸ë¦¼ì„ ë°›ì•„ì™€ì•¼ í•©ë‹ˆë‹¤.
        micInterval = setInterval(() => {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                // í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•´ ëœë¤ ë°ì´í„° ì±„ì›€
                const buffer = new Uint8Array(1024);
                for(let i=0; i<10; i++) buffer[i] = Math.floor(Math.random() * 255);

                websocket.send(buffer);
                logBinary(buffer, 'SENT');
            }
        }, 1000);
    }

    function stopMic() {
        isMicOn = false;
        document.getElementById('btnMic').textContent = "ğŸ™ï¸ ë§ˆì´í¬ ì¼œê¸°";
        document.getElementById('audioStatus').textContent = "ë§ˆì´í¬ êº¼ì§";
        if (micInterval) clearInterval(micInterval);
    }
</script>
</body>
</html>